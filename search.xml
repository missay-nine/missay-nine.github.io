<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>clean</title>
      <link href="/2024/04/26/clean/"/>
      <url>/2024/04/26/clean/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解-树网的核</title>
      <link href="/2024/04/26/%E9%A2%98%E8%A7%A3-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/"/>
      <url>/2024/04/26/%E9%A2%98%E8%A7%A3-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>原题链接 <a href="https://www.luogu.com.cn/problem/P1099"> 树网的核</a></p><p><img src="/2024/04/26/%E9%A2%98%E8%A7%A3-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/image-20240426124319242.png" alt="image-20240426124319242"></p><p>题目大致意思是，找一条路径，在满足小于s的情况下，使得偏心距最小。什么是偏心距呢？偏心距指的是树网中所有点离路径距离最大的距离，我们要使最大值最小化，乍一听有点像二分。题目大致就是这个意思</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于树的直径，这是一个板子题，大致思路就是随机找一个点，找到离这个点最大距离的点，然后再在这个点，继续搜索，找到距离这个点最大的点，那么这两点链接的长度即为树的直径，具体证明可以看，<a href="https://oi-wiki.org/graph/tree-diameter/">树的直径</a><br><img src="/2024/04/26/%E9%A2%98%E8%A7%A3-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/image-20240426124725510.png" alt="image-20240426124725510"></p><p>这里有详细的证明，好了，我们在解决树的直径之后，那么如何求解偏心距呢？是这样的，我们以某条直径来说，通过缩小直径，根据贪心的思想，路径在不超过S的情况下，尽可能越大越好，这样到每个点的距离都会缩小。我们在讨论 如果直径上我们只选取一个点，那么距离这个点最大的一定是，我们选出直径中某一个点距离这个点最大距离的点，如果这个点距离这个点最大且不是直径上的，那么我们可以说之前找的直径有误，因为我们可以把这个点到所找的点的距离给拼接上，舍去之前找到的直径，所以假设不成立。他一定是直径上的点。我们要考虑的答案来源有两个：</p><p><img src="/2024/04/26/%E9%A2%98%E8%A7%A3-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/image-20240426125230295.png" alt="image-20240426125230295"></p><p>我们看橙色路径 ，在满足路径长度不大于s的情况下，这个树网的直径可以是AC 也可以是AB,   我们橙色路径，首先找到直径两端到选取路径的最大值，因为前面说了可能是偏心距的来源，此外还要找直径之外的点，他们距离直径的距离可能会大于所选路径下，直径端点距离距离所选路径的距离，可能有点绕，请仔细琢磨┭┮﹏┭┮。比如说DEFG 这条路径，直径上最大的距离该路径的距离的端点是C 距离为5，但是B 距离路径长度是8 所以偏心距是8 。那我们可以怎么写呢，首先选出树的直径出来，然后在直径的某一个端点开始，运用双指针，滑动窗口，先滑窗到小于等于S 的路径 ，然后偏心距 取 直径两端点 最大距离D， ans = min(ans,D),遍历完成之后，我们枚举所有不在直径上的点距离他们离的最近的直径点的距离，如果不是离的最近的，而是经过了直径上的其他点，那么他的距离还可以缩小，答案是不对的，至此 思路大概就是这些，接下来贴上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 他想的和我的差不多doge233 </span></span><br><span class="line"><span class="comment">//创建时间：2017-10-12 21:19:24 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;edges[N];</span><br><span class="line"><span class="type">int</span> dist[N],pre[N];</span><br><span class="line"><span class="type">bool</span> vis[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x )</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> edge:edges[x])&#123;</span><br><span class="line"> <span class="type">int</span> y = edge.first;</span><br><span class="line"> <span class="type">int</span> w = edge.second;</span><br><span class="line"> <span class="keyword">if</span>(y!=pre[x]&amp;&amp;!vis[y])&#123;</span><br><span class="line"> pre[y] = x;</span><br><span class="line"> dist[y] = dist[x] + w;</span><br><span class="line"> <span class="built_in">dfs</span>(y);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">edges[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">edges[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化清空</span></span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">pre[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>,v = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[i] &gt; v)&#123;</span><br><span class="line">v = dist[i];</span><br><span class="line">idx = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二次dfs 以这个为根 </span></span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">pre[idx] = <span class="number">-1</span>;</span><br><span class="line">v = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(idx);</span><br><span class="line"><span class="type">int</span> idx1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dist[i] &gt; v)&#123;</span><br><span class="line">v = dist[i];</span><br><span class="line">idx1 = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> ans = <span class="number">1000000</span>,j = idx1;</span><br><span class="line"><span class="comment">// 先算 直径上的偏心距离 当长度为这个 离路径最远的最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = idx1;i&gt;<span class="number">0</span>;i=pre[i]) &#123;</span><br><span class="line"><span class="comment">// j移动 </span></span><br><span class="line"><span class="keyword">while</span>(pre[j] &amp;&amp; dist[i] - dist[pre[j]]&lt;=s) j =pre[j];</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">max</span>(dist[j],dist[idx1]-dist[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i  = idx1;i&gt;<span class="number">0</span>;i=pre[i]) vis[i] = <span class="number">1</span>;<span class="comment">//为什么要标记？</span></span><br><span class="line"><span class="comment">// 因为 这个我们要找的是离直径上该点最远的点，我们吧直径上的点都标记了</span></span><br><span class="line"><span class="comment">// 防止他记错，就是已经到直径了 他还继续走这样子 </span></span><br><span class="line"><span class="comment">// memset(dist,0,sizeof(dist));</span></span><br><span class="line"><span class="comment">// 他只会走 跟他相连的节点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = idx1;i&gt;<span class="number">0</span>;i=pre[i])  dist[i] = <span class="number">0</span>, <span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) ans = <span class="built_in">max</span>(ans,dist[i]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 尺取法 </span></span><br><span class="line"><span class="comment">// 有个不同的是他有个visit 如果你确定</span></span><br><span class="line"><span class="comment">// 有直径了 那么直径外距离直径最大的点</span></span><br><span class="line"><span class="comment">// 将是你的阻碍 真的我不知道他是怎么想出来的</span></span><br><span class="line"><span class="comment">// 牛的 就是咋说呢 偏心距是最大值中的最小值</span></span><br><span class="line"><span class="comment">// 我们的路径当然是越大越好，这样到各个点就会越近</span></span><br><span class="line"><span class="comment">// 如果直径越来越长 那么直径上的偏心距就会越来越小，我们此时可能看得就不是</span></span><br><span class="line"><span class="comment">// 直径上的点了，而是直径外的点，如果直径越来越小，那么距离路径最大的</span></span><br><span class="line"><span class="comment">//  肯定是直径上的点，如果不是，是直径外的点，那么这个直径就是假直径</span></span><br><span class="line"><span class="comment">// 假设不成立啊。 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当s 的限制导致路径缩短成一个点 之后，</span></span><br><span class="line"><span class="comment">// 最大的路径节点肯定是直径上的，否则他就不是直径好吧</span></span><br><span class="line"><span class="comment">// 如果路径不止一个点，那么答案就是尽可能从中心点扩展出去，这样使得最大最小</span></span><br><span class="line"><span class="comment">// 答案的来源有两种 就是 直径上的两端点到取得路径  之间的最大距离</span></span><br><span class="line"><span class="comment">// 其二 就是 ，非直径上的  ，其实也不是 肯定是另一条直径的末端 到已选直径上的最大距离</span></span><br><span class="line"><span class="comment">// 还有什么呢 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于树的问题，一定要熟悉如何建树，一些相对应的板子要默写的很熟。多敲多练。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置域名</title>
      <link href="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/"/>
      <url>/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="讲一下具体过程"><a href="#讲一下具体过程" class="headerlink" title="讲一下具体过程"></a>讲一下具体过程</h2><p>  可以借助vercel 来部署，但是 vercel需要科学上网，这里就不多说了 ，主要记录一下今天配置个人域名的情况。首先去腾讯云买一个域名。</p><p><a href="https://buy.cloud.tencent.com/domain/buy?domain=missay&tlds=.com&from=dnspodEntrance"> 腾讯云</a></p><p><img src="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/image-20231208190517630.png" alt="image-20231208190517630"></p><p>购买一个自己喜欢的域名，然后前往vercel。</p><p>找到自己关联的项目。</p><p><img src="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/image-20231208190633452.png" alt="image-20231208190633452"></p><p>点domains 进入编辑</p><p><img src="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/image-20231208190704942.png" alt="image-20231208190704942"></p><p>添加你所需要的添加的域名，之后会提示你进行配置</p><p><img src="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/image-20231208190741859.png" alt="image-20231208190741859"></p><p>然后你就可以去，你所买的域名进行管理，进行域名解析。</p><p>完成之后，等待一阵子，就可以正常访问了。</p><p><img src="/2023/12/08/%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/image-20231208191706827.png" alt="image-20231208191706827"></p><p>至此全部结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常随笔-12-08</title>
      <link href="/2023/12/08/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94-12-08/"/>
      <url>/2023/12/08/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94-12-08/</url>
      
        <content type="html"><![CDATA[<h2 id="所得所失"><a href="#所得所失" class="headerlink" title="所得所失"></a>所得所失</h2><p>关于一些，问题，不要太纠结细节。面对失败，我们更多的应该保持乐观积极态度，善于总结，直面困难是最好的。by the way  今天刚买的域名，打算给博客用，不过可能还有一点小问题，就是域名相关的权限好像还未分发，所以明天再看一下，不要太纠结了。为什么想写这一篇随笔，就是陪伴两年的物品，由于个人疏忽，导致损坏，感觉还是有点难过的，个人不应该在路上看手机，导致直接摔坑里了orz。就当算个教训了。人生总是在失败中前进，没有人能够一帆风顺。活在当下，稍作调整，继续前进。东西坏了就是坏了，无法破镜重圆，就像是时间，一去不复返，如若停留在原地，那么便会陷入桎梏，再也无法逃出来，或许人生来就不完美，但是我们可以接受这个不完美，毕竟，真正完美的人，是一个少数，我们只需要做到最好就好了。活在当下，珍惜每一秒的时光，保持热爱，不负青春</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2023/11/24/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2023/11/24/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="金币游戏有感"><a href="#金币游戏有感" class="headerlink" title="金币游戏有感"></a>金币游戏有感</h2><p>没下注之前，我感觉我自己每次都能赢，还在想着，像这个游戏，我怎么可能输呢。可是，当我下注之后，我就输了，输的一塌糊涂。我想，这个游戏，我怎么可能赢呢。陷入了一种悲观，心砰砰的跳，像这种1/2的几率，咋可能每次都输，遇到不会的直接自己写算法随机模拟一个数选就可以了，但是很多人看到前面出了这么多次小，就会觉得，这次一定是大，然后就会输，这就是人性的弱点，如概率论来说，前后产生的结果并没有什么联系，如果这个游戏是公平的话，前面出了6次小，那么这次出现小的概率也是1/2，并不是说这次一定就是大。我感觉如若庄家说的是对的，开奖结果全凭借玩家下单的结果生成的。保持一个平常心，不要被前面的结果所影响，这样不至于输的一塌糊涂，如果猜对的概率是1/2，我昨天试了下，下注十次只猜对一次，发现自己的运气是真的差啊。不要全凭自己观察已出的结果来下注，可能就会输的很惨，保持平常心即可。为此，我还在图书馆看了一下博弈论，发现博弈论是一个很有意思的学科，我也想学习一下，看看能不能用到生活中。比如说万元陷阱，田忌赛马，等，有些人可能是天选之子，运气确实特别好，通过此次游戏，我觉得心态最重要，保持平常心，通过这个游戏来锻炼自己，平时玩玩小的就行了。不用太纠结。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习-3-vue</title>
      <link href="/2023/11/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-3-vue/"/>
      <url>/2023/11/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-3-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习_2_ts</title>
      <link href="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/"/>
      <url>/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/</url>
      
        <content type="html"><![CDATA[<h2 id="Ts-的学习"><a href="#Ts-的学习" class="headerlink" title="Ts 的学习"></a>Ts 的学习</h2><h4 id="安装ts"><a href="#安装ts" class="headerlink" title="安装ts"></a>安装ts</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><p>初始化ts </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init </span><br></pre></td></tr></table></figure><p>下载一个包？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ts-node -g</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @types/node -D</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p><img src="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/image-20231104195206643.png" alt="image-20231104195206643"></p><p> 顶级类型 any unknown   object</p><p>Number String Boolean</p><p>number  string boolean </p><p>对象是大写 实现是小写</p><p>unknown 只能赋给自身，或者是any</p><h5 id="object-Object"><a href="#object-Object" class="headerlink" title="object   Object"></a>object   Object</h5><p>object 只能用引用类型？不支持原始类型</p><p>{}类型无法做修改</p><h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><p>自定义类型</p><p>interface Z  后面跟着打要大写</p><p>interface Z{</p><p>  name : string</p><p>  age:number</p><p>}</p><p>可以在字段前面加一个 readonly 只可以读</p><p>接口可以继承接口</p><p>extend 关键字</p><p>基本类型都差不多 讲一下 不常见的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>交叉类型</p><p>类型断言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fn = function(num:number | string):void&#123;</span><br><span class="line">console.log((num as string).length)</span><br><span class="line">&#125;</span><br><span class="line">fn(12345)</span><br></pre></td></tr></table></figure><p>断言 把某些东西转换成某些类型。</p><h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>Number Date RegExp  等等。</p><p>dom对象 bom</p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>class 关键字</p><p>抽象类</p><p>抽象类 只能描述，不能定义</p><p>抽象类可以被其他类实现</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>enum</p><h5 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h5><h5 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h5><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>作用：相当于强类型语言中的类型声明</p><p>语法:(变量/函数):type</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>:<span class="built_in">boolean</span>=<span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组里面加 | 可以混杂其他类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">number</span>,<span class="built_in">string</span>] = [<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="comment">// 元组长度不能改变？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数 </span></span><br><span class="line"> add = (<span class="attr">x</span>:<span class="built_in">number</span>,<span class="attr">y</span>:<span class="built_in">number</span>):<span class="function"><span class="params">number</span> =&gt;</span> x + y</span><br><span class="line"><span class="comment">// 可以在括号后面加返回值类型，其实可以省略，他会自动类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123;<span class="attr">x</span>: <span class="built_in">number</span>,<span class="attr">y</span>:<span class="built_in">number</span>&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//symbol </span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s1</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: undefine = underfined</span><br><span class="line"><span class="keyword">let</span> <span class="attr">nu</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">noReturn</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//any</span></span><br><span class="line"><span class="keyword">let</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">//never 永远不会有返回值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">error</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">endless</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有关枚举类型"><a href="#有关枚举类型" class="headerlink" title="有关枚举类型"></a>有关枚举类型</h4><p><img src="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/image-20231104203354890.png" alt="image-20231104203354890"></p><p>枚举：一组有名字的常量集合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Role</span>&#123;</span><br><span class="line">    <span class="title class_">Reporter</span>,</span><br><span class="line">    <span class="title class_">Developer</span>,</span><br><span class="line">    <span class="title class_">Maintainer</span>,</span><br><span class="line">    <span class="title class_">Owner</span>,</span><br><span class="line">    <span class="title class_">Guest</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以自定义初始值 后面的相对应递增。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Role</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="title class_">Success</span> = <span class="string">&#x27;恭喜&#x27;</span>,</span><br><span class="line">    <span class="title class_">Fail</span> = <span class="string">&#x27;抱歉&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异构枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Answer</span>&#123;</span><br><span class="line">    N,</span><br><span class="line">    Y = <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举成员</span></span><br><span class="line"><span class="title class_">Role</span>.<span class="property">Reporter</span> = <span class="number">2</span> <span class="comment">// 错误 枚举成员是只读类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举成员两种类型</span></span><br><span class="line"><span class="comment">// const  menber 常量</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Char</span>&#123;</span><br><span class="line">    <span class="comment">//  编译的时候计算结果，以常量出现</span></span><br><span class="line">    a,</span><br><span class="line">    b = <span class="title class_">Char</span>.<span class="property">a</span>,</span><br><span class="line">    c = <span class="number">1</span>+ <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// computed  不会再编译的时候的运算</span></span><br><span class="line">    d = <span class="title class_">Math</span>.<span class="title function_">random</span>(),</span><br><span class="line">    e = <span class="string">&#x27;123&#x27;</span>.<span class="property">Length</span> </span><br><span class="line">    <span class="comment">// 注意 computed 后面 继续的枚举 要赋值，负责报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量枚举</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Month</span>&#123;</span><br><span class="line">    <span class="title class_">Jan</span>,</span><br><span class="line">    <span class="title class_">Feb</span>,</span><br><span class="line">    <span class="title class_">Mar</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 不需要对象 只需要值</span></span><br><span class="line"><span class="keyword">let</span>  month = [<span class="title class_">Month</span>.<span class="property">Jan</span>,<span class="title class_">Month</span>.<span class="property">Feb</span>,<span class="title class_">Month</span>.<span class="property">Mar</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> E &#123;a,b&#125;</span><br><span class="line"><span class="keyword">enum</span> F &#123;a=<span class="number">0</span>,b=<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">enum</span> G &#123;a = <span class="string">&#x27;apple&#x27;</span>,b = <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>: F = <span class="number">3</span> </span><br><span class="line"><span class="comment">// e 和 f 不可以直接比较 他们是不同的枚举类型。</span></span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">   <span class="comment">//签名</span></span><br><span class="line">    [<span class="attr">x</span>:<span class="built_in">string</span>]；<span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interfave <span class="title class_">Result</span>&#123;</span><br><span class="line">  data <span class="title class_">List</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">result: Result</span>)&#123;</span><br><span class="line">  result.<span class="property">data</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">id</span>,value.<span class="property">name</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = &#123;</span><br><span class="line">    <span class="attr">data</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;B&#x27;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态语言 鸭子类型 如果直接复制给对象则会报错，比如说赋值给render 就不行了  如何绕过类型检查 第一种 声明一个变量，第二个类型断言  “ as type ” 要么在对象后面加一个&lt;type&gt;。 要么使用字符串签名。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//readonly 只读属性 不允许被修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名</span></span><br><span class="line">[<span class="attr">x</span>:<span class="built_in">string</span>]:<span class="built_in">string</span></span><br><span class="line"><span class="comment">//  数字索引签名返回值一定要是 字符串索引签名返回值的子类型，因为JavaScript 默认会将number 类型转换成string ？ 视频</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外问了下newbing 关于索引签名的事情</p><p>涉及到TypeScript中的索引签名（index signature）的用法和规则。索引签名是一种用来描述对象的结构的类型注解，它指定了对象的键和值的类型。索引签名有两种形式，一种是字符串索引签名，另一种是数字索引签名。字符串索引签名的形式是[key: string]: ValueType，表示对象的键是字符串类型，值是ValueType类型。数字索引签名的形式是[key: number]: ValueType，表示对象的键是数字类型，值是ValueType类型。</p><p>在你的例子中，你定义了一个接口MyObject，它有两个索引签名，一个是字符串索引签名，一个是数字索引签名。这样的接口是合法的，但是有一些限制和约束。首先，数字索引签名的值类型必须是字符串索引签名的值类型的子类型或相同类型。这是因为JavaScript会将数字类型的键转换为字符串类型的键，所以数字索引签名实际上是字符串索引签名的一种特殊情况。如果数字索引签名的值类型和字符串索引签名的值类型不一致，那么就会出现类型不兼容的错误。例如，你的第一个例子中，数字索引签名的值类型是number，而字符串索引签名的值类型是string，这就不满足子类型或相同类型的要求，所以会报错。你的第二个例子中，数字索引签名的值类型和字符串索引签名的值类型都是string，这就满足了要求，所以不会报错。</p><p>其次，如果一个接口有两个索引签名，那么它不能有其他的属性。这是因为索引签名表示对象的结构是不确定的，它可以有任意数量和类型的键，所以不能再添加其他的确定的属性。如果一个接口有其他的属性，那么它只能有一个索引签名，而且这个索引签名的值类型必须包含或相同于其他属性的值类型。例如，下面的接口是合法的，因为它只有一个索引签名，而且这个索引签名的值类型是string | number，它包含了其他属性的值类型：</p><p>interface MyObject { [key: string]: string | number; name: string; age: number; }</p><p>大致是这样子的 必须包括 或者相等 下面是newbing 生成的一首诗。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript is a poem by Bing</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Poem</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">author</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TypeScript</span>: <span class="title class_">Poem</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;TypeScript&quot;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&quot;Bing&quot;</span>,</span><br><span class="line">  <span class="attr">content</span>: [</span><br><span class="line">    <span class="string">&quot;TypeScript is a superset of JavaScript,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It adds types and interfaces to the script,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It helps you write code that is clear and robust,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It catches errors and bugs before they erupt.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TypeScript is a language that compiles to JavaScript,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It runs on any browser or platform that supports it,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It offers features like classes, generics and modules,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It makes your code more readable, reusable and scalable.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TypeScript is a poem that expresses my admiration,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is a tribute to the developers who created this innovation,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is a challenge to the programmers who want to learn this creation,&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is a invitation to the readers who want to enjoy this narration.&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">TypeScript</span>.<span class="property">title</span> + <span class="string">&quot; by &quot;</span> + <span class="title class_">TypeScript</span>.<span class="property">author</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">TypeScript</span>.<span class="property">content</span>.<span class="title function_">join</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lib</span>&#123;</span><br><span class="line">    ():<span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">verision</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">doSomething</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLib</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">lib</span>:<span class="title class_">Lib</span> = (<span class="function">() =&gt;</span> &#123;&#125;) <span class="keyword">as</span> <span class="title class_">Lib</span>;</span><br><span class="line">    lib.<span class="property">version</span> = <span class="string">&#x27;1.0&#x27;</span>;</span><br><span class="line">    lib.<span class="property">doSomething</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> lib;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  let lib: Lib = (() =&gt; &#123;&#125; ) as Lib 是啥意思没看懂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 答：在这段代码中，`let lib: Lib = (() =&gt; &#123;&#125;) as Lib` 是在创建一个名为 `lib` 的变量，并将其类型标记为 `Lib`。这行代码的作用是将一个匿名函数表达式（`() =&gt; &#123;&#125;`）强制类型转换为 `Lib` 类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*让我解释一下这个代码的每个部分：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. `let lib: Lib`：这部分定义了一个名为 `lib` 的变量，并指定了它的类型为 `Lib`。这意味着 `lib` 变量必须符合 `Lib` 接口的定义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. `(() =&gt; &#123;&#125;)`：这是一个匿名函数表达式，它代表一个空函数，不执行任何操作。在这里，它被用作一个立即执行的函数，也就是在声明后立即执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. `as Lib`：这是一个类型断言，它告诉 TypeScript 编译器将 `(() =&gt; &#123;&#125;)` 这个函数表达式视为 `Lib` 类型，即满足 `Lib` 接口的定义。虽然 `(() =&gt; &#123;&#125;)` 不满足 `Lib` 接口的定义，但是通过类型断言，你告诉编译器将其视为 `Lib` 类型，因此不会出现类型错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合起来，这行代码创建了一个名为 `lib` 的变量，并将其初始化为一个空的匿名函数，然后将其类型标记为 `Lib`，以便后续可以将属性 `version` 和方法 `doSomething` 添加到 `lib` 变量中，使其符合 `Lib` 接口的定义。这是一种用于创建对象的方式，通常用于实现一种接口或类的结构。</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>4种定义函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">add2</span>:<span class="function">(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> add3 = <span class="function">(<span class="params">x:mumber,y:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> add4&#123;</span><br><span class="line">    (<span class="attr">x</span>:<span class="built_in">number</span>,<span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面三种 只是定义并没有实现。</p><p>函数可以加可选参数，但是可选参数必须在必选参数后面。或者可以给参数提供一个默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function add6(x:number,y=0,z:number,q=1)</span><br></pre></td></tr></table></figure><p>如果默认参数 在需要传参的前面，那么必须传入一个underfine，否则会报错。如果在后面则无所谓。</p><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>同一个函数名字，但是对应参数不一样。或者是返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add8(...rest:number[]):number;</span><br><span class="line">function add8(...rest:string[]:string;)</span><br><span class="line">function add8(...rest:any[]): any&#123;</span><br><span class="line">   leet firstt = rest[0]</span><br><span class="line">   if (typeof first === &#x27;string&#x27;)&#123;</span><br><span class="line">     return  rest.join(&#x27;&#x27;)</span><br><span class="line">   &#125;</span><br><span class="line">   if(typeof first === &#x27;number&#x27;)&#123;</span><br><span class="line">    return  rest.reduce((pre,cur) =&gt; pre + cur ) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><h5 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;wangcai&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog)</span><br></pre></td></tr></table></figure><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Husky</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Dog</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span> (<span class="attr">name</span>:<span class="built_in">string</span>,<span class="attr">color</span>:<span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">color</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的属性 有三种 public  private protect</p><p>记得以前学java 阿伟讲的很清楚。</p><p>public 谁都能进 </p><p>private 只有类成员 才能进</p><p>protect 就是名义上是这个家的成员也能进 受法律保护。外面的孩子。只能在类或者子类中使用，不能在实例中使用</p><h5 id="抽象类和多态"><a href="#抽象类和多态" class="headerlink" title="抽象类和多态"></a>抽象类和多态</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">sleep</span>():<span class="built_in">void</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">    <span class="title function_">constructoi</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> </span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dog is sleeping&#x27;</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;wangcai&#x27;</span>)</span><br><span class="line">dog.<span class="title function_">sleep</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cat is sleeping&#x27;</span>s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">animals</span>: <span class="title class_">Animal</span>[] = [dog,cat]</span><br><span class="line">animals.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">    i.<span class="title function_">sleep</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkFlow</span>&#123;</span><br><span class="line">    <span class="title function_">step1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">step2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WorkFlow</span>().<span class="title function_">step1</span>().<span class="title function_">step2</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myglow</span> <span class="keyword">extends</span> <span class="title class_ inherited__">WorkFlow</span>&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Myflow</span>().<span class="title function_">next</span>().<span class="title function_">stpe1</span>().<span class="title function_">next</span>().<span class="title function_">step2</span>()</span><br></pre></td></tr></table></figure><h4 id="类和接口之间的关系"><a href="#类和接口之间的关系" class="headerlink" title="类和接口之间的关系"></a>类和接口之间的关系</h4><p>类可以实现接口</p><p>接口之间可以互相继承</p><p>接口继承类 such as</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Auto</span>&#123;</span><br><span class="line">    state = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AutoInterface</span> <span class="keyword">extends</span> <span class="title class_">Auto</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> inplements <span class="title class_">AutoInterface</span>&#123;</span><br><span class="line">    state = <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Auto</span> inplements <span class="title class_">AutoInterface</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/image-20231105100428773.png" alt="image-20231105100428773"></p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>不预先确定的数据类型，具体的类型在使用的时候 才能确定</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> log&lt;T&gt;(<span class="attr">value</span>:T):T&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log&lt;<span class="built_in">string</span>[]&gt;([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="title function_">log</span>([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Log</span> = &lt;T&gt;<span class="function">(<span class="params">value:T</span>) =&gt;</span> T</span><br><span class="line">&lt;T&gt; 表示这个函数类型是一个泛型函数类型，其中 T 是一个类型参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Log</span>&lt;T&gt;&#123;</span><br><span class="line">    &#123;<span class="attr">value</span>: T&#125;:T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现的时候 需要定义一个类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myLog</span>: <span class="title class_">Log</span>&lt;<span class="built_in">number</span>&gt; = log</span><br><span class="line"><span class="title function_">myLog</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以指定默认的类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Log</span>&lt;T = <span class="built_in">string</span>&gt;&#123;</span><br><span class="line">    (<span class="attr">value</span>:T):T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型类与泛型约束"><a href="#泛型类与泛型约束" class="headerlink" title="泛型类与泛型约束"></a>泛型类与泛型约束</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Length</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> log&lt;T extend <span class="title class_">Length</span>&gt;(<span class="attr">value</span>:T):T&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value,value.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>([<span class="number">1</span>])</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-2-ts/image-20231105101953120.png" alt="image-20231105101953120"></p><h4 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h4><h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>不需要指定变量的类型(函数的返回值类型),typescript可以根据某些规则自动地为其推断出一个类型</p><ul><li>基础类型推断</li><li>最佳通用类型推断</li><li>上下文类型推断</li></ul><p>类型断言可以自己指定属性，不需要他来推断</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Foo</span></span><br><span class="line"><span class="keyword">for</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尽量还是自己声明类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="title class_">Foo</span> = &#123;</span><br><span class="line">    bar : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h4><p>当一个类型Y 可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y</p><p>X兼容Y: X(目标类型) = Y(源类型)</p><p>关闭tsconfig.json 中的‘strictNullChecks’</p><p>string s  可以被赋值给null</p><p>字符型可以兼容null类型。</p><p>源类型如果包括一个类型的所有类型，成员少的可以兼容成员多的。</p><p>对象类型 和 接口类型不一样？</p><p>对象： 成员对象多的可以兼容成员少的 跟接口 相反。</p><p>？ 没懂</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3D</span>&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point2D</span>&#123;</span><br><span class="line"> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"> <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">p3d</span> = (<span class="params">point:Point3D</span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">p2d</span> = (<span class="params">point:Point2D</span>) =&gt; &#123;&#125;; </span><br><span class="line">为什么 <span class="title class_">Point2D</span> = point3D</span><br><span class="line">而 p2d = p3d 则不行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是因为在 TypeScript 中，接口（Interface）和函数的类型检查机制是不同的。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>对于接口，TypeScript 使用的是结构性类型系统。在这种类型系统中，如果 <code>TypeA</code> 是 <code>TypeB</code> 的子类型，那么 <code>TypeA</code> 的对象可以赋值给 <code>TypeB</code> 的对象。在你的例子中，<code>Point3D</code> 接口包含了 <code>Point2D</code> 接口的所有属性，因此 <code>Point3D</code> 可以看作是 <code>Point2D</code> 的子类型，所以 <code>Point3D</code> 类型的对象可以赋值给 <code>Point2D</code> 类型的对象²。</del></p><p><del>然而，对于函数，TypeScript 使用的是名义类型系统。在这种类型系统中，函数的参数类型必须完全匹配。也就是说，如果一个函数的参数类型是 <code>TypeA</code>，那么我们只能将类型为 <code>TypeA</code> 的对象传递给这个函数，不能将 <code>TypeA</code> 的子类型的对象传递给这个函数¹。在你的例子中，函数 <code>p3d</code> 和 <code>p2d</code> 的参数类型分别是 <code>Point3D</code> 和 <code>Point2D</code>，尽管 <code>Point3D</code> 是 <code>Point2D</code> 的子类型，但你不能将 <code>p3d</code> 赋值给 <code>p2d</code>，因为 <code>p3d</code> 接受的参数类型是 <code>Point3D</code>，而 <code>p2d</code> 接受的参数类型是 <code>Point2D</code>，这两者并不完全匹配¹。 */</del></p><p><del>在 TypeScript 中，你可以将 <code>p2d</code> 赋值给 <code>p3d</code>，因为 <code>p2d</code> 函数接受的参数类型 <code>Point2D</code> 是 <code>p3d</code> 函数参数类型 <code>Point3D</code> 的超类型。换句话说，任何 <code>Point2D</code> 类型的对象都是 <code>Point3D</code> 类型的对象，因此 <code>p2d</code> 函数可以接受任何 <code>p3d</code> 函数可以接受的参数。</del></p><p><del>这是因为在 TypeScript 的类型系统中，函数的兼容性是基于参数列表和返回类型的。对于参数列表，TypeScript 采用 “鸭子类型”（Duck Typing）或 “结构子类型化”（Structural Subtyping）。在这种类型系统中，如果 <code>TypeB</code> 的每个属性都存在于 <code>TypeA</code> 中，那么 <code>TypeB</code> 就被认为是 <code>TypeA</code> 的子类型。因此，如果一个函数 <code>f1</code> 的每个参数都存在于另一个函数 <code>f2</code> 的参数列表中，那么 <code>f1</code> 就可以被赋值给 <code>f2</code>。</del></p><p><del>所以，你可以将 <code>p2d</code> 赋值给 <code>p3d</code>，但不能将 <code>p3d</code> 赋值给 <code>p2d</code>，因为 <code>p3d</code> 的参数类型 <code>Point3D</code> 包含了 <code>p2d</code> 的参数类型 <code>Point2D</code> 中没有的属性 <code>z</code>。</del></p><p>有待商榷 上面 后面在寻找资料。</p><h5 id="枚举兼容性"><a href="#枚举兼容性" class="headerlink" title="枚举兼容性"></a>枚举兼容性</h5><p>enum Fruit{Apple,Banana}</p><p>enum Color{Red,Yellow}</p><p>let fruit:Fruit.Apple = 3</p><p>let no: number = Fruit.Apple</p><p>let color: Color.Red  = Fruit.App  这是不行的</p><p>// 类的兼容性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">p:<span class="built_in">number</span>,q:<span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">    <span class="attr">id</span>: numner = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> =<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> s = <span class="number">1</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">p:<span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">    <span class="attr">id</span>:<span class="built_in">number</span> = <span class="number">2</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>= <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有私有成员   创建的两个实例是兼容的/*</span></span><br><span class="line">/因为 都具有一个实例属性id  构造函数和静态成员是不做比较的。*/</span><br><span class="line">有私有成员 父类和子类是互相兼容的</span><br></pre></td></tr></table></figure><h5 id="泛型兼容"><a href="#泛型兼容" class="headerlink" title="泛型兼容"></a>泛型兼容</h5><p>只有在泛型给成员变量使用时才会影响兼容性</p><h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><h4 id="交叉类型和联合类型"><a href="#交叉类型和联合类型" class="headerlink" title="交叉类型和联合类型"></a>交叉类型和联合类型</h4><hr><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习_1</title>
      <link href="/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2023/11/03/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 虽然之前学了一点html css 但是还是不够熟练，今天来学习是想重新熟悉一下流程，以及相关操作</p><h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>网站上有些功能啥的，比如说点赞？评论？ 就是 字体图标。<br>用color 可以改变颜色，字体图标展示的是图标，本质是字体。<br><strong>优点</strong><br>灵活性<br>轻量级<br>兼容性</p><p>图标库 iconfont 阿里的图标库</p><p>如何使用？</p><ol><li>引入字体图标的样式表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;</span><br></pre></td></tr></table></figure><p>2.调用图标对应的类名，必须调用两个<font color="#FF0000">类名</font></p><p>iconfont类</p><p>图标对应的类。</p><p>::before 是干什么的？</p><p>伪元素，它可以在选择的元素的内容之前插入一些修饰性的内容，比如文字、图片、图标等。这个伪元素默认是一个行内元素，它的样式可以通过content属性和其他CSS属性来定义</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>实现一些简单的动画出现。</p><h2 id="仿b站网页端"><a href="#仿b站网页端" class="headerlink" title="仿b站网页端"></a>仿b站网页端</h2><p> 网页的设计 可以参考别人怎么写的 ，素材的话</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java接口开发流程</title>
      <link href="/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><p>maven 配置</p><p>记录一下 maven配置 得到的经验</p><p>首先 如果你IDEA 和JDK 用的都是比较新的话，那么建议MAVEN也配置比较新的，不然感觉会有很多问题，比如说创建maven项目一直在 read maven project   虽然可以直接删除</p><p>wrapper 下面的maven-wrapper.properties 可以解决这个问题，但是我不想每次创建项目的时候都有这个问题，于是把maven3.6.2版本的给卸载了，毕竟太老了，下载了一个3.9.5的。安装完之后发现确实没有这个问题了。</p><p>首先去maven 官网下载最新版本</p><p>[maven官网][<a href="https://maven.apache.org/download.cgi]">https://maven.apache.org/download.cgi]</a></p><p>下载你需要的版本 </p><p>下载好zip文件 ，解压缩到你电脑上的一个目录</p><p><img src="/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/image-20231102152201782.png" alt="image-20231102152201782"></p><p>然后就是配置了，在环境变量配置一个MAVEN_HOME </p><p>里面对应的值就是 maven解压所在的目录。</p><p><img src="/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/image-20231102152707931.png" alt="image-20231102152707931"></p><p>然后再PATH 这个变量下 新增一条 %MAVEN_HOME%\bin</p><p><img src="/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/image-20231102152756904.png" alt="image-20231102152756904"></p><p>然后cmd 里面输入 mvn -v</p><p> 可以看到版本号说明配置好了。</p><p>接下来配置仓库，配置一个本地仓库 ，在maven里面 创建一个mvn_repo 的目录 ，之后在conf文件夹中找到settings.xml</p><p>里面配置 localRepository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;E:\develop_java\apache-maven-3.9.5\mvn_repo&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>上面是我配置的路径。</p><p><img src="/2023/11/01/java%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/image-20231102153134754.png" alt="image-20231102153134754"></p><p>阿里云 配置 就是在找到mirror标签配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">     <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对了 maven3.8之后会多个这个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.      <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不知道有什么用 先注释了。</p><p>到这里差不多就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慎独</title>
      <link href="/2023/10/18/%E6%85%8E%E7%8B%AC/"/>
      <url>/2023/10/18/%E6%85%8E%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>​        何为慎独？中庸中写道”莫见乎隐，莫显乎微，故君子慎其独也”大概意思就是在没有他人在的情况下，能够做到跟他人的情况下一样 严格要求自己，也要表里一致。严守本分，不做坏事，不自欺。</p><h4 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h4><p>​     为什么 今天想起写这些 ，正如tags 中所写 ，只是日常随笔，接触到学校生活的事情有感而发罢了。在这之前，又想说一下，自律自控自制 这三个关键词。</p><p> 自律：个人理解就是自己能够对自己规定的计划，而去按时实现，没有人强迫你去做。自觉的去做。不为他人而工作。</p><p>自控：自我控制的能力，对于冲动，感情，欲望等等，能够控制好自己，进行自我支配。</p><p>自制：一个人控制自己的思想情感和举止行为的能力，这点我感觉跟自律和自控是有交杂的。中华文化博大精深。这些浩如烟海的词汇，使得人们流连忘返、</p><h4 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h4><p>​    在大学的学习之中，其实相对是比较轻松的，因为到了大学没有人管着你，你可以自由分配时间。对于大学生，大一可能还保留高中的习惯，认真上课，认真写作业，可是越到后面，越放纵自己，整日无所事事，待在宿舍里追剧打游戏。诸如此类 的事情似乎已经是一种常态。</p><p>关于大学的学习，我觉得缺少不了上面几个能力，对于自律，我觉得我已经做的还是不错的，在闲暇之余可以，自觉到图书馆学习八小时以上。但是自控和自制能力稍微差了一点。但是如果自控自制能力差会导致，你身体上或是精神上的坏结果。</p><hr><p>更新</p><p>2023年10月24日23:02:35</p><p>代码是敲出来的 不是看出来的，写文也是如此，上次提到慎独，就应该时刻提醒自己，什么是该做的，什么是不该做的。只有自己做一遍才会印象深刻。现在学校考试啥的就是基本短期记忆，用完就丢。可能就是教育的一种失败，应试教育有点严重，创新点不足。就想到这么多。</p>]]></content>
      
      
      <categories>
          
          <category> 学习生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2023/10/15/%E9%9A%8F%E7%AC%94/"/>
      <url>/2023/10/15/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h3 id="大学生活"><a href="#大学生活" class="headerlink" title="大学生活"></a>大学生活</h3><p>​    大学生活已经接近尾声了，虽然大一开始刷牛客，但是始终不敢跨出那一步，总以为自己还差一点。其实能尽早接触企业开发是最好的，因为自己学总是有点局限性。一定要去做，因为看太多是没有用的。只有自己去理解实现才可以。废话也不多讲，下周继续开投，一定要去做好吧。</p><p>   像后端 计算机网络 os  数据库，不过我看招聘要求 说是数据库挺重要的。多看看吧，感觉还是要去敲。光看是没有用的。项目 算法 基础 八股 这些。差不多 以后还是要多写多记。打破迷茫的最好办法就是去做。</p>]]></content>
      
      
      <categories>
          
          <category> 学习生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年10月13日20:22:07日记</title>
      <link href="/2023/10/13/2023%E5%B9%B410%E6%9C%8813%E6%97%A520-22-07%E6%97%A5%E8%AE%B0/"/>
      <url>/2023/10/13/2023%E5%B9%B410%E6%9C%8813%E6%97%A520-22-07%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好久没有写博客了 ，之前提到 不能拖延 ，但是 感觉还是拖延了不少! 现在开始 尽量每天一篇吧。</p><p><img src="/2023/10/13/2023%E5%B9%B410%E6%9C%8813%E6%97%A520-22-07%E6%97%A5%E8%AE%B0/56DZ%5D6M(1S_WBK%60Y5)@1M4N.jpg" alt="img"></p><h4 id="今天内容"><a href="#今天内容" class="headerlink" title="今天内容"></a>今天内容</h4><p>看了mysql  ，计算机网络，  早上写了下算法。感觉长路漫漫，不知道今后的路应该如何走。牛客也只会越刷越焦虑，害，距离毕业也只有一年了。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 日常随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滕王阁序</title>
      <link href="/2023/03/25/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/"/>
      <url>/2023/03/25/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p><p>画栋朝飞南浦云，珠帘暮卷西山雨。</p><p>闲云潭影日悠悠，物换星移几度秋。</p><p>阁中帝子今何在？槛外长江空自流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习有感</title>
      <link href="/2023/03/21/%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/03/21/%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="应试类学习"><a href="#应试类学习" class="headerlink" title="应试类学习"></a>应试类学习</h2><p>  谈到学校，可能大部分学校都是类似这个样子，大多数科目成了记忆类型的科目往往只需要背诵，应付期末考试就可以，所以有些人考的很好，但是没有多久就忘了。这就是典型的应试学习。这类人可能在学校学的很好，但是在工作可能会显得很吃力。如何抉择好学校与社会的关系，也是一种能力。在处理好学校课程的情况下，还要自己主动学习新的内容，为以后的工作打好基础，属实是一种不容易的事情。</p><h3 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h3><p>​      以下是我个人的见解，当日事，当日毕。不要拖，这是我从模电老师那里得到的一句话。上海交大的郑益慧。他说过他就喜欢当天的事情当日就要完成。不要喜欢拖延，因为尽管拖延很舒服，可能在那一天来说，可是在deadline到来，就会显得手忙脚乱。</p><hr><p>(暂未完成)</p>]]></content>
      
      
      <categories>
          
          <category> 学习生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习习惯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missay one day</title>
      <link href="/2023/03/19/missay-one-day/"/>
      <url>/2023/03/19/missay-one-day/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>  爱的初体验</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><pre><code>世间美好与你环环相扣</code></pre>]]></content>
      
      
      <categories>
          
          <category> blog1 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
